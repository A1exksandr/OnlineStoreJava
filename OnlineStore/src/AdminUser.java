public class AdminUser extends User {

    private String role;

    public AdminUser(String username, String password, String email) {
        /*
         * Вызываем конструктор родительского класса (User).
         * Без вызова super(...) компилятор автоматически попытается
         * вызвать конструктор по умолчанию User(), которого может и не быть.
         */
        super(username, password, email);
        this.role = "Admin";
    }

    // Переопределяем метод login(), чтобы добавить поведение админа
    @Override
    public void login() {
        // Используем логику родителя
        super.login();
        // Добавляем дополнительное поведение
        System.out.println("Вам предоставлен доступ к админ-панели. Роль: " + role);
        System.out.println("Ваша почта: " + email);
    }

    // Getter и setter для роли (если понадобится)
    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
    }

    /*
     * Обрати внимание на область видимости:
     * - Поля у нас protected, чтобы подклассы (наследники) могли их видеть.
     * - Если сделать private, то в AdminUser не будет прямого доступа.
     */

    /*
    * Ключевые моменты наследования:
    * 1.Ключевое слово extends — означает, что AdminUser является наследником User.
    * 2. Конструктор наследника обязательно должен вызывать конструктор родителя (неявно или явно через super(...)).
    * 3. Поля:
    * - Если поля private в родительском классе, то в наследнике их напрямую использовать нельзя. Нужно либо делать protected, либо использовать геттеры/сеттеры.
    * 4. Переопределение методов:
    * - Осуществляется с помощью аннотации @Override. Если метод так не пометить, есть риск допустить опечатку и не переопределить, а создать новый метод.
    * 5. Типичные ошибки:
    * - Забыть вызвать super(...) в конструкторе наследника.
    * - Попытаться обратиться к приватным полям родителя напрямую.
    * - Перепутать перегрузку (overload) и переопределение (override).
     */


    /*
     * ДЗ 1 (простое):
     * 1) Создай класс ManagerUser, который наследуется от User.
     * 2) В конструкторе ManagerUser задавай роль "Manager".
     * 3) Переопредели метод login(), чтобы выводилось
     *    "Пользователь с ролью Manager залогинился" + логика родителя.
     * 4) Создай объект ManagerUser и протестируй его работу.
     */

    /*
     * ДЗ 2 (чуть сложнее):
     * 1) Добавь в класс User поле email и соответствующие геттер/сеттер.
     * 2) В AdminUser и ManagerUser переопредели метод login(), чтобы он
     *    выводил ещё и email пользователя.
     * 3) Проанализируй, как правильно вызвать геттер email в наследниках.
     */

    /*
     * ДЗ 3 (творческое):
     * 1) Создай класс GuestUser (гость), наследующий User.
     *    У GuestUser может не быть пароля (придумай, как это обыграть в коде).
     * 2) Переопредели login(), чтобы выводить, что гость зашёл как временный пользователь.
     * 3) Продумай, стоит ли иметь отдельное поле "role" или, например, enum "UserRole" и т.д.
     */



}

